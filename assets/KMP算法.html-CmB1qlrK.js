import{_ as s,c as a,a as t,o as p}from"./app-Bcxw9xI6.js";const e={};function c(o,n){return p(),a("div",null,n[0]||(n[0]=[t(`<blockquote><p>本部分如果想要视频解析，推荐看天勤的解析<a href="https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener noreferrer">【天勤考研】KMP算法易懂版</a>，本人也是看了天勤的解析才写下本文</p></blockquote><p>KMP算法用于快速比较两个字符串，从主串中匹配一个给定的模式串，KMP算法解决了简单暴力算法中模式串指针的需要来回移动的问题，执行起来效率更高</p><blockquote><p>[!warning] 提示 本文中所有代码均默认串从1位置开始</p></blockquote><h2 id="简单暴力算法" tabindex="-1"><a class="header-anchor" href="#简单暴力算法"><span>简单暴力算法</span></a></h2><p>为什么这么说呢，先来看一个暴力算法的例子</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> length<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> Str<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span>Str s<span class="token punctuation">,</span> Str subs<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 定义三个指针，i j指向主串和模式串，k指向上一次主串中不相等的位置</span></span>
<span class="line">    <span class="token comment">// 这里假设字符串都是从1位置开始</span></span>
<span class="line">    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 如果当前指针所指位置相等，指针后移一位</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> subs<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            i<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            j<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 匹配失败，模式串相对主串后移一位</span></span>
<span class="line">            i <span class="token operator">=</span> <span class="token operator">++</span>k<span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 再次从模式串初始位置开始遍历</span></span>
<span class="line">            j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> k<span class="token punctuation">;</span>  <span class="token comment">// 匹配成功，返回模式串在主串中的位置</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 否则返回失败标记</span></span>
<span class="line"> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设我们需要从串 <strong>&quot;ABAABABBABAAABA&quot;</strong> 中找到 <strong>ABBABA</strong> 所在的位置</p><p><img src="https://r2.lm379.cn/2025/03/5228dc4fe647d2775c10f04330c2cd45.png" alt=""></p><p>简单暴力算法中，我们让主串和模式串分别从1位置开始遍历，当遍历到 <code>s.ch[3]</code> 和 <code>subs.ch[3]</code>时，发生不匹配，此时会让模式串相对主串后移一位，重新开始遍历</p><p><img src="https://r2.lm379.cn/2025/03/8ea542fa5c99aac91a5536ff072abf12.png" alt=""></p><p>而很明显，将模式串后移一位后，<code>s.ch[2] != subs.ch[1]</code>，此时仍然需要将模式串后移一位，如下图</p><p><img src="https://r2.lm379.cn/2025/03/5d536c483e5776dd12097527757814c4.png" alt=""></p><p>在某一次循环后，当 <code>s.ch[6] != subs.ch[3]</code> 时，需要再次后移模式串，会将模式串指针 <code>j</code> 重新指向1</p><p><img src="https://r2.lm379.cn/2025/03/22341a574c0c34bab48ee2fa902c9c7b.png" alt=""></p><p>很明显后移一次会使得 <code>s.ch[5] != subs.ch[1]</code> ，需要再次移动模式串</p><p><img src="https://r2.lm379.cn/2025/03/48e659c4ec56fa6f0882d20fea552de8.png" alt=""></p><p>最终成功匹配到字串，此时指针 <code>j</code> 已经指向模式串末尾，根据上面的代码，会将指针 <code>j++</code> 变成 <code>7</code>，使得 <code>j &gt; subs.length</code>，不满足循环条件跳出循环，并返回主串中匹配成功的位置 <code>6</code></p><p><img src="https://r2.lm379.cn/2025/03/6a6a0cd600f5789ac7c18188972e650f.png" alt=""></p><h2 id="kmp算法" tabindex="-1"><a class="header-anchor" href="#kmp算法"><span>KMP算法</span></a></h2><p>kmp算法实际上是一个动态规划问题，求next数组实际上就是动态规划过程中的dp数组，下面是解析</p><h3 id="算法分析" tabindex="-1"><a class="header-anchor" href="#算法分析"><span>算法分析</span></a></h3><p>从上面的过程可以看到，在移动字串的过程中始终有如下这种 <code>主串与模式串头位置就匹配失败</code></p><p><img src="https://r2.lm379.cn/2025/03/48e659c4ec56fa6f0882d20fea552de8.png" alt=""></p><p>或者 <code>主串与模式串已经比较过的部分匹配失败</code></p><blockquote><p>如这里已经比较过主串的 <code>1 2 3 4 5</code>位置与模式串 <code>1 2 3 4 5</code>位置相同 <img src="https://r2.lm379.cn/2025/03/d0f3c580f31d31fdd45ba6a49fa17da7.png" alt=""> 但是在移动模式串时，只将模式串移动了一位 <img src="https://r2.lm379.cn/2025/03/16ef0c9d9f77d466868d116cc88cf1fe.png" alt=""></p></blockquote><p>能不能跳过中间这些直接就失败的状态呢？这就是KMP算法会解决的问题</p><p>还是以这个为例</p><p><img src="https://r2.lm379.cn/2025/03/d0f3c580f31d31fdd45ba6a49fa17da7.png" alt=""></p><p>KMP算法会直接进行如下的过程，并从主串的 <code>6</code> 位置与模式串的 <code>3</code> 位置开始比较 <img src="https://r2.lm379.cn/2025/03/264d89e982771d07c8b0b37efb4207a8.png" alt=""></p><p><em>这个过程是怎么来的呢？</em></p><p>首先 KMP 算法会找到模式串发生不匹配位置（上面的6位置）以前的 <strong>最长公共子串</strong>，如下图 <img src="https://r2.lm379.cn/2025/03/96f7d16eac0a5653a1a685c86405c1ea.png" alt=""></p><p>并直接将前面一个字串移动到后面一个字串的位置</p><p><img src="https://r2.lm379.cn/2025/03/c61872bb0cf5bc9d77796e518ae0b0f0.png" alt=""></p><p>而在计算机中其实不能实现将模式串后移这种操作，所以通过代码实现就是将 <code>i</code> 指针不动，<code>j</code> 指针移动到 <strong>最长公共子串+1</strong> 的位置(比如上面就是3位置)，让 <code>s.ch[i]</code> 和 <code>subs.ch[j]</code> 继续比较，从而跳过了很多重复的失败过程，同时避免了 <code>j</code> 指针的来回移动</p><p>而在字串中每个位置都可能发生不匹配，每个位置都可以向前找到最长公共子串，且和模式串位置一一对应，因此我们也可以用一个数组来存储下一步主串和模式串需要比较的位置，因此求得的这个数组就被称作下一步数组，也叫 <strong>next</strong> 数组</p><p>根据上面的描述，KMP算法匹配模式串的步骤就分解成了三步</p><blockquote><p>[!TIP]</p><ol><li>求每个位置之前的最长公共字串长度</li><li>求解next数组</li><li>遍历主串与模式串，发生不匹配时执行 <code>j=next[j]</code>，继续遍历</li></ol></blockquote><h3 id="求解next数组" tabindex="-1"><a class="header-anchor" href="#求解next数组"><span>求解Next数组</span></a></h3><p>从上面可以看到，求解next数组最重要的一步是求最长公共子串，或者叫最长公共前后缀 上面这个例子中，模式串总长度比较短，可以在很快的求得每个位置的最长公共子串如下所示</p><table><thead><tr><th>数组下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>模式串</td><td></td><td>A</td><td>B</td><td>B</td><td>A</td><td>B</td><td>A</td></tr><tr><td>next</td><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>3</td></tr></tbody></table><p>其中会出现一些特殊情况，比如1 2 3位置，这几个位置是没有公共前后缀的，所以对这个过程做出一些规定</p><blockquote><p>[!NOTE] 特殊情况</p><ol><li>next 数组第 1 位置直接赋值为 0 ，表示直接将模式串后移一位 <strong>(或指向主串的指针后移)</strong></li><li>没有公共前缀的地方赋值为1</li></ol></blockquote><p>但是假如模式串很长，直接求解最长子串的过程其实就跟简单暴力算法没什么区别了，所以这一个过程也可以进行优化</p><p>以下面的模式串为例，我们已经求得了6位置的next值3，现在要求7位置的next值，怎么办呢？</p><table><thead><tr><th>数组下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>模式串</td><td></td><td>A</td><td>B</td><td>B</td><td>A</td><td>B</td><td>A</td><td>B</td><td>B</td><td>A</td><td>B</td></tr><tr><td>next</td><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>3</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>这里为了更直观表示此过程，将模式串复制一份，再按照下面的方式对其两个串，这是不是又回到了上面的求解主串与模式串的匹配与否问题呢</p><p><img src="https://r2.lm379.cn/2025/03/1d3cb40f32583f6f8808094f274132ad.png" alt=""></p><p>而在这个例子中，已经求得了 <code>next[6] = 3</code> ，而这个值表示的是 <code>6</code> 位置之前的最长公共子串的长度+1，现在要得到 <code>7</code> 位置的最长公共子串</p><p>假如 <code>subs.ch[6] == subs.ch[3]</code>，说明子串中 <code>1~3位置</code>和 <code>4~6位置</code>相等，即这部分是最长公共前后缀，直接让 <code>next[7] = next[6] + 1</code> 即可</p><p>假如不相等，那么就回到了主串与模式串匹配问题中，发生不匹配时子串的指针应该跳到哪里的问题，上面这里就是在子串 <code>3</code> 位置发生不匹配，<code>next[3]</code> 已知，而 <code>subs.ch[next[3]] == subs.ch[7]</code> 所以 <code>next[7] = next[3] = 1</code></p><p><strong>接下来由特殊推广为一般情况</strong></p><p>假如需要求解 <code>next[j]</code> 的值，而 <code>next[j-1] = t</code>，只需要比较 <code>subs.ch[t]</code> 与 <code>subs.ch[j-1]</code> 是否相等 若相等，<code>next[j] = next[j-1] + 1</code> 否则，<code>t = next[t]</code> ，再执行一次判断，直到匹配或 <code>t == 0</code>为止</p><p>C++代码实现如下</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">getnext</span><span class="token punctuation">(</span>Str subs<span class="token punctuation">,</span> <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// j指针指向字符串</span></span>
<span class="line">    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 对应特殊情况 1，规定首位为 0</span></span>
<span class="line">    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>subs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> subs<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">==</span> subs<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">            next<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>t<span class="token punctuation">;</span> <span class="token comment">// 等同于 t++; j++; next[j]=t;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            t <span class="token operator">=</span> next<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kmp代码" tabindex="-1"><a class="header-anchor" href="#kmp代码"><span>KMP代码</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">kmp</span><span class="token punctuation">(</span>Str s<span class="token punctuation">,</span> Str subs<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>s<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>subs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> subs<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">            i<span class="token operator">++</span><span class="token punctuation">;</span>  </span>
<span class="line">            j<span class="token operator">++</span><span class="token punctuation">;</span>  </span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  </span>
<span class="line">            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  </span>
<span class="line">        <span class="token punctuation">}</span>  </span>
<span class="line">    <span class="token punctuation">}</span>  </span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  </span>
<span class="line">        <span class="token keyword">return</span> i<span class="token operator">-</span>subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的kmp demo代码可见 <a href="https://gitee.com/lm379/datastr/blob/main/kmp.cpp" target="_blank" rel="noopener noreferrer">kmp.cpp · lm379/datastr - 码云 - 开源中国</a></p><p><a href="https://beian.miit.gov.cn" target="_blank" style="color:var(--c-text-lighter);text-align:center;">蜀ICP备2022016740号-2</a></p>`,58)]))}const i=s(e,[["render",c]]),d=JSON.parse('{"path":"/posts/KMP%E7%AE%97%E6%B3%95.html","title":"KMP算法","lang":"zh-CN","frontmatter":{"title":"KMP算法","date":"2025-03-20T10:51:48.000Z","tag":["算法","动态规划"],"Category":"数据结构","top":1},"headers":[{"level":2,"title":"简单暴力算法","slug":"简单暴力算法","link":"#简单暴力算法","children":[]},{"level":2,"title":"KMP算法","slug":"kmp算法","link":"#kmp算法","children":[{"level":3,"title":"算法分析","slug":"算法分析","link":"#算法分析","children":[]},{"level":3,"title":"求解Next数组","slug":"求解next数组","link":"#求解next数组","children":[]},{"level":3,"title":"KMP代码","slug":"kmp代码","link":"#kmp代码","children":[]}]}],"git":{"updatedTime":1743056641000,"contributors":[{"name":"lm379","username":"lm379","email":"2645081603@qq.com","commits":1,"url":"https://github.com/lm379"}],"changelog":[{"hash":"ab0cf891c3eb10fad68be9c0b135e80b26788c99","time":1743056641000,"email":"2645081603@qq.com","author":"lm379","message":"first"}]},"filePathRelative":"posts/KMP算法.md","excerpt":"<blockquote>\\n<p>本部分如果想要视频解析，推荐看天勤的解析<a href=\\"https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.337.search-card.all.click\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">【天勤考研】KMP算法易懂版</a>，本人也是看了天勤的解析才写下本文</p>\\n</blockquote>\\n<p>KMP算法用于快速比较两个字符串，从主串中匹配一个给定的模式串，KMP算法解决了简单暴力算法中模式串指针的需要来回移动的问题，执行起来效率更高</p>"}');export{i as comp,d as data};
